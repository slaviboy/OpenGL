/*
 * Copyright (C) 2020 Stanislav Georgiev
 * https://github.com/slaviboy
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.slaviboy.opengl.main

import android.graphics.Matrix
import android.graphics.PointF
import android.view.MotionEvent

/**
 * Gesture detection using a transformation matrix, the changes according to
 * gestures made by the user, supported gestures are Move, Scale and Rotate.
 * All transformations are then applied to a matrix, that can be used to
 * transform array with coordinates as float array, paths or canvas elements.
 */
open class OpenGLMatrixGestureDetector(var matrix: Matrix = Matrix()) {

    private var pointerIndex = 0
    private val tempMatrix: Matrix = Matrix()
    private val source = FloatArray(4)
    private val distance = FloatArray(4)
    private var count = 0

    // device width
    var width: Float = 0f
        set(value) {
            field = value
            ratio = (width / height)
        }

    // device height
    var height: Float = 0f
        set(value) {
            field = value
            ratio = (width / height)
        }


    var ratio = 1f                                  // width/height ratio
    private val convertMatrix = Matrix()            // matrix used in the conversion, that way no new matrix is created for each call
    private val convertMatrixInvert = Matrix()      // invert matrix of the convert matrix

    lateinit var listener: OnMatrixChangeListener   // listener that for event called when matrix is updated

    fun onTouchEvent(event: MotionEvent) {

        // only two fingers
        if (event.pointerCount > 2) {
            return
        }

        val action = event.actionMasked
        val index = event.actionIndex
        when (action) {

            MotionEvent.ACTION_DOWN, MotionEvent.ACTION_POINTER_DOWN -> {

                // get the coordinates for the particular finger
                val idx = index * 2
                source[idx] = event.getX(index)
                source[idx + 1] = event.getY(index)

                count++
                pointerIndex = 0
            }

            MotionEvent.ACTION_MOVE -> {
                var i = 0
                while (i < count) {
                    val idx = pointerIndex + i * 2
                    distance[idx] = event.getX(i)
                    distance[idx + 1] = event.getY(i)
                    i++
                }

                // use poly to poly to detect transformations
                tempMatrix.setPolyToPoly(source, pointerIndex, distance, pointerIndex, count)
                matrix.postConcat(tempMatrix)
                System.arraycopy(distance, 0, source, 0, distance.size)

                // trigger the callback
                if (::listener.isInitialized) {
                    listener.onChange(this)
                }
            }

            MotionEvent.ACTION_UP, MotionEvent.ACTION_POINTER_UP -> {
                if (event.getPointerId(index) == 0) pointerIndex = 2
                count--
            }
        }
    }

    /**
     * Get the converted OpenGL matrix with transformation, from the
     * graphic matrix, that is generated by finger gestures.
     * @param sourceMatrix matrix with previous transformations
     * @param destinationMatrix matrix with applied transformation
     */
    fun transform(sourceMatrix: FloatArray, destinationMatrix: FloatArray) {

        // get graphics matrix values
        val v = FloatArray(9)
        this.matrix.getValues(v)

        // get translate value for the OpenGL coordinate system
        v[2] = normalizeTranslateX(v[2])
        v[5] = normalizeTranslateY(v[5])

        // set rotation, scaling and translation from graphics matrix to form new 4x4 OpenGL matrix
        val openGLMatrix = floatArrayOf(
            v[0], v[3], 0f, 0f,
            v[1], v[4], 0f, 0f,
            0f, 0f, 1f, 0f,
            v[2], v[5], 0f, 1f
        )

        // multiply sourceMatrix and openGLMatrix to generate the new matrix
        android.opengl.Matrix.multiplyMM(destinationMatrix, 0, sourceMatrix, 0, openGLMatrix, 0)
    }

    /**
     * Get the coordinate of point from the MotionEvent object, to a OpenGL
     * coordinate system. Without any transformations applied.
     * @param x x coordinate from MotionEvent object
     * @param y y coordinate from MotionEvent object
     * @param result point with resulted OpenGL coordinates
     */
    fun normalizeCoordinates(x: Float, y: Float, result: PointF) {

        // get graphics matrix values
        val v = FloatArray(9)
        this.matrix.getValues(v)

        // get translate value for the OpenGL coordinate system
        v[2] = normalizeTranslateX(v[2])
        v[5] = normalizeTranslateY(v[5])

        // get the invert matrix
        convertMatrix.setValues(v)
        convertMatrix.invert(convertMatrixInvert)

        // map coordinate using the invert matrix
        val xOpenGL = normalizeTranslateX(x)
        val yOpenGL = normalizeTranslateY(y)
        val coords = floatArrayOf(xOpenGL, yOpenGL)
        convertMatrixInvert.mapPoints(coords)

        // set the result point with the new coordinates
        result.x = coords[0]
        result.y = coords[1]
    }

    fun normalizeWidth(width: Float, isScalable: Boolean): Float {
        var openGLWidth = (width / this.width) * OpenGLRenderer.NEAR * ratio
        if (!isScalable) {
            openGLWidth /= this.matrix.scale()
        }
        return openGLWidth
    }

    /**
     * Get the converted translate x coordinate from the graphic matrix translation
     * to the OpenGL translation, since they use different coordinate systems.
     */
    fun normalizeTranslateX(x: Float): Float {

        val translateX = if (x < width / 2f) {
            -1f + (x / (width / 2f))
        } else {
            (x - (width / 2f)) / (width / 2f)
        }

        return -translateX * OpenGLRenderer.NEAR * ratio
    }

    /**
     * Get the converted translate y coordinate from the graphic matrix translation
     * to the OpenGL translation, since they use different coordinate systems.
     */
    fun normalizeTranslateY(y: Float): Float {

        val translateY = if (y < height / 2f) {
            1f - (y / (height / 2f))
        } else {
            -(y - (height / 2f)) / (height / 2f)
        }

        return translateY * OpenGLRenderer.NEAR
    }

    /**
     * Listener triggered when the matrix is changed when new gesture is detected from
     * the user. The first argument is the matrix with the updated transformations.
     */
    interface OnMatrixChangeListener {
        fun onChange(matrixGestureDetector: OpenGLMatrixGestureDetector)
    }

    /**
     * Get the scale factor for a given matrix
     */
    fun Matrix.scale(): Float {
        val points = FloatArray(9)
        getValues(points)

        val scaleX: Float = points[Matrix.MSCALE_X]
        val skewY: Float = points[Matrix.MSKEW_Y]
        return Math.sqrt(scaleX * scaleX + skewY * skewY.toDouble()).toFloat()
    }

    /**
     * Get the rotation angle for a given matrix
     */
    fun Matrix.angle(): Float {
        val points = FloatArray(9)
        getValues(points)
        val scaleX: Float = points[Matrix.MSCALE_X]
        val skewX: Float = points[Matrix.MSKEW_X]
        return (Math.atan2(skewX.toDouble(), scaleX.toDouble()) * (180 / Math.PI)).toFloat()
    }

    /**
     * Get transformations for a given matrix
     */
    fun Matrix.transform(): PointF {
        val points = FloatArray(9)
        getValues(points)
        return PointF(points[Matrix.MTRANS_X], points[Matrix.MTRANS_Y])
    }
    //endregion
}